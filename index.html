<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GPU Stress / Check (WebGL)</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      background: #0b0b0b;
      color: #eee;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    .wrap {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 12px;
      height: 100%;
      padding: 12px;
      box-sizing: border-box;
    }

    canvas {
      width: 100%;
      height: 100%;
      background: #000;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
    }

    .panel {
      padding: 12px;
      background: #0f1720;
      border-radius: 10px;
      box-shadow: 0 8px 30px rgba(2, 6, 23, 0.6);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    label {
      font-size: 13px;
      color: #cbd5e1;
      min-width: 120px;
    }

    input[type=range] {
      width: 100%;
    }

    button {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      background: #06b6d4;
      color: #022;
      cursor: pointer;
      font-weight: 600;
    }

    button.warn {
      background: #fb7185;
      color: #2b0216;
    }

    small {
      color: #94a3b8
    }

    .stat {
      font-family: monospace;
      background: #071026;
      padding: 8px;
      border-radius: 6px
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div style="display:flex;flex-direction:column;gap:12px;">
      <canvas id="glcanvas"></canvas>
      <div style="display:flex;gap:12px;align-items:center;">
        <div class="stat" id="fps">FPS: --</div>
        <div class="stat" id="gpuUsage">Render Size Mult: 1.0x</div>
        <div class="stat" id="runtime">Run: 0s</div>
        <div class="stat" id="warn"
          style="color:#fef2f2;background:#3f0000;padding:8px;border-radius:6px;display:none;">STOP: Device overheating
          or low performance!</div>
      </div>
    </div>

    <div class="panel" role="region" aria-label="Controls">
      <h3 style="margin:0 0 6px 0;">GPU Check Controls</h3>
      <div class="row">
        <label for="resMul">Render Size Mult</label>
        <input id="resMul" type="range" min="0.25" max="2.5" step="0.25" value="1">
      </div>
      <div class="row">
        <label for="iters">Shader Iterations</label>
        <input id="iters" type="range" min="8" max="500" step="8" value="64">
      </div>
      <div class="row">
        <label for="intensity">Intensity</label>
        <input id="intensity" type="range" min="0.2" max="4.0" step="0.1" value="1.0">
      </div>
      <div class="row">
        <label for="fpsLimit">Frame Cap (0=no cap)</label>
        <input id="fpsLimit" type="range" min="0" max="60" step="1" value="0">
      </div>

      <div class="row">
        <button id="startBtn">Start</button>
        <button class="warn" id="stopBtn">STOP</button>
        <button id="stressBtn">Enable Stress Mode</button>
      </div>

      <div style="margin-top:6px;font-size:13px;">
        <small>
          Tips: Start with mild settings. Stress Mode will push resolution & iterations higher. Monitor temperature and
          battery — stop if device heats up.
        </small>
      </div>

      <hr style="border:none;border-top:1px solid #0b1220;margin:6px 0;">
      <div>
        <small>Result logs (best copy/paste):</small>
        <pre id="log"
          style="white-space:pre-wrap;background:#010811;padding:8px;border-radius:6px;height:140px;overflow:auto;color:#9ae6b4;font-size:12px;margin-top:6px;"></pre>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    if (!gl) {
      alert('WebGL not available in this browser.');
      throw new Error('WebGL unavailable');
    }

    // Simple vertex shader (fullscreen tri)
    const vert = `#version 300 es
in vec2 aPos;
out vec2 uv;
void main(){ uv = aPos*0.5 + 0.5; gl_Position = vec4(aPos,0.0,1.0); }`;

    // Fragment shader doing heavy per-pixel loop; iterations and intensity are uniforms
    const frag = `#version 300 es
precision highp float;
in vec2 uv;
out vec4 outColor;
uniform float uTime;
uniform vec2 uRes;
uniform float uIter;
uniform float uIntensity;

// pseudo heavy workload: iterative trig + noise-ish mixing
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }
vec3 heavy(vec2 p){
  float v = 0.0;
  vec2 q = p;
  for (int i=0;i<1024;i++){
    if(float(i) >= uIter) break;
    // mix trig and fract ops to keep GPU busy
    q = vec2(
      cos(q.x*1.4 + uTime*0.001) - sin(q.y*0.7),
      sin(q.y*1.7 - uTime*0.0007) + cos(q.x*0.9)
    );
    v += abs(sin(dot(q, q)*0.031 + float(i)*0.013)) * 0.5;
    // a cheap hash combo
    v += hash(q + float(i)*0.17)*0.2;
    // some non-linear combine
    q *= 1.0003 + 0.00007*float(i);
  }
  return vec3(v);
}

void main(){
  vec2 p = (uv - 0.5) * (uRes / min(uRes.x,uRes.y));
  vec3 c = heavy(p) * uIntensity;
  // brighten & tone map
  c = 1.0 - exp(-c);
  outColor = vec4(c, 1.0);
}`;

    // utility to compile shader/program
    function createProgram(vsSrc, fsSrc) {
      const v = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(v, vsSrc);
      gl.compileShader(v);
      if (!gl.getShaderParameter(v, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(v));

      const f = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(f, fsSrc);
      gl.compileShader(f);
      if (!gl.getShaderParameter(f, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(f));

      const p = gl.createProgram();
      gl.attachShader(p, v); gl.attachShader(p, f);
      gl.bindAttribLocation(p, 0, 'aPos');
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
      return p;
    }

    const program = createProgram(vert, frag);
    gl.useProgram(program);

    // fullscreen triangle buffer
    const quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    // uniform locations
    const uTime = gl.getUniformLocation(program, 'uTime');
    const uRes = gl.getUniformLocation(program, 'uRes');
    const uIter = gl.getUniformLocation(program, 'uIter');
    const uIntensity = gl.getUniformLocation(program, 'uIntensity');

    let last = performance.now();
    let frame = 0;
    let fps = 0;
    let fpsCounter = 0;
    let fpsLastTime = performance.now();
    let running = false;
    let startTime = 0;
    let animateId = null;
    let runtimeSeconds = 0;
    let autoStopTemp = false;

    const resMulEl = document.getElementById('resMul');
    const itersEl = document.getElementById('iters');
    const intensityEl = document.getElementById('intensity');
    const fpsCapEl = document.getElementById('fpsLimit');

    const fpsEl = document.getElementById('fps');
    const gpuUsageEl = document.getElementById('gpuUsage');
    const runtimeEl = document.getElementById('runtime');
    const warnEl = document.getElementById('warn');
    const logEl = document.getElementById('log');

    function resizeCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const mul = parseFloat(resMulEl.value);
      const width = Math.max(64, Math.floor(window.innerWidth * 0.65 * mul * ratio));
      const height = Math.max(64, Math.floor((window.innerHeight - 40) * mul * ratio));
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = '';
      canvas.style.height = '';
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.uniform2f(uRes, canvas.width, canvas.height);
      gpuUsageEl.textContent = `Render Size Mult: ${mul.toFixed(2)}x (${canvas.width}×${canvas.height})`;
    }

    window.addEventListener('resize', resizeCanvas);
    resMulEl.addEventListener('input', () => { resizeCanvas(); });

    function log(msg) {
      const now = new Date().toLocaleTimeString();
      logEl.textContent = `[${now}] ${msg}\n` + logEl.textContent;
    }

    document.getElementById('startBtn').addEventListener('click', () => {
      if (running) return;
      running = true;
      startTime = performance.now();
      runtimeSeconds = 0;
      fpsLastTime = performance.now();
      frame = 0;
      log('Start rendering');
      animate();
    });
    document.getElementById('stopBtn').addEventListener('click', stop);
    function stop() {
      if (!running) return;
      running = false;
      if (animateId) cancelAnimationFrame(animateId);
      animateId = null;
      log('Stopped rendering by user');
      warnEl.style.display = 'none';
      document.getElementById('startBtn').disabled = false;
    }

    let stressMode = false;
    document.getElementById('stressBtn').addEventListener('click', (e) => {
      stressMode = !stressMode;
      e.target.textContent = stressMode ? 'Stress Mode ON' : 'Enable Stress Mode';
      // push settings when enabled
      if (stressMode) {
        resMulEl.value = Math.min(2.5, Math.max(1.0, parseFloat(resMulEl.value)));
        itersEl.value = Math.min(500, Math.max(128, parseInt(itersEl.value)));
        intensityEl.value = Math.min(4.0, Math.max(1.5, parseFloat(intensityEl.value)));
        log('Stress Mode enabled (higher load).');
        resizeCanvas();
      } else {
        log('Stress Mode disabled.');
      }
    });

    function animate(now) {
      animateId = requestAnimationFrame(animate);
      if (!running) return;

      // frame limiting if requested
      const fpsCap = parseInt(fpsCapEl.value, 10);
      if (fpsCap > 0) {
        const minDelta = 1000 / fpsCap;
        if (now - last < minDelta) return;
      }

      const dt = now - last;
      last = now;
      frame++;
      fpsCounter++;
      // every 500ms update fps display
      if (now - fpsLastTime >= 500) {
        fps = Math.round((fpsCounter * 1000) / (now - fpsLastTime));
        fpsEl.textContent = 'FPS: ' + fps;
        fpsCounter = 0;
        fpsLastTime = now;
      }

      // time and uniforms
      const t = (now - startTime) * 0.001;
      gl.uniform1f(uTime, t);
      gl.uniform1f(uIter, parseFloat(itersEl.value));
      gl.uniform1f(uIntensity, parseFloat(intensityEl.value));

      // draw
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      runtimeSeconds = Math.floor((now - startTime) / 1000);
      runtimeEl.textContent = `Run: ${runtimeSeconds}s`;

      // Basic heuristic watch: if fps drops very low quickly, warn & auto-stop after threshold
      if (fps > 0 && fps < 6 && runtimeSeconds > 3) {
        warnEl.style.display = 'block';
        log(`Low FPS detected (${fps}). Consider stopping. Auto-stop in 5s if persists.`);
        if (!autoStopTemp) { autoStopTemp = now; }
        if (now - autoStopTemp > 5000) { log('Auto-stopping due to sustained low FPS'); stop(); }
      } else {
        warnEl.style.display = 'none';
        autoStopTemp = false;
      }

      // safety: optional time limit hard stop if user leaves running > 10min
      if (runtimeSeconds > 10 * 60) {
        log('Auto-stopped after 10 minutes (safety limit).');
        stop();
      }
    }

    // initialize
    resizeCanvas();
    log('Ready. Adjust settings and press Start.');

    // initial uniform set
    gl.uniform1f(uTime, 0.0);
    gl.uniform1f(uIter, parseFloat(itersEl.value));
    gl.uniform1f(uIntensity, parseFloat(intensityEl.value));
  </script>
</body>

</html>